call plug#begin('~/.vim/plugged')

" Let gvim colorschemes work; not sure if we need this but can't
" hurt
Plug 'godlygeek/csapprox'

" Colorscheme
Plug 'tpope/vim-vividchalk'

" Git Wrapper; don't use it a lot, but maybe should some day
Plug 'tpope/vim-fugitive'

" extended % matching for HTML, LaTeX, and many other languages
Plug 'tmhedberg/matchit'

" Entended undo capabilities
Plug 'sjl/gundo.vim'

" Puppet syntax and stuff
Plug 'rodjek/vim-puppet'

" Ack Searching
Plug 'mileszs/ack.vim'

" Tabular Alignment
Plug 'junegunn/vim-easy-align'

" fzf fuzzy finding tool
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
" ctrl-[a-z], alt-[a-z], f[1-4], or any single character
let g:fzf_action = {
  \ 'ctrl-m': 'tabedit',
  \ 'alt-t': 'tabedit' }

call plug#end()

" Common keypresses that I want to be fast to hit

" I keep having to reload because Fuf gets confused
nnoremap <Space>v :source ~/.vimrc<CR>

" Don't bind the leader because other things bind it
" let mapleader = ","

" Open a new split
nnoremap <Space>s :split<CR>

" Move around between splits
nnoremap <Space>h <C-W>h
nnoremap <Space>l <C-W>l
nnoremap <Space>j <C-W>j
nnoremap <Space>k <C-W>k

" Open various panels or whatever
nnoremap <Space>a :tabnew<CR>:Ack<Space>''<Left>
nnoremap <Space>n :tabnew<CR>

" Close all but the current window in the current tab (for dropping stuff like Ack)
nnoremap <Space>q :cclose<CR>:only<CR>
" Close the currrent tab
nnoremap <Space>Q :tabclose<CR>
" Attempt to close the current buffer
nnoremap <Space>d :bdelete<CR>

" Aligning things in columns based on next character ; see
" https://github.com/junegunn/vim-easy-align
nmap <Space>A <Plug>(EasyAlign)
vmap <Space>A <Plug>(EasyAlign)
vmap <Enter> <Plug>(EasyAlign)

" Fugitive
nnoremap <Space>gs :Gstatus<CR>
nnoremap <Space>gc :Gcommit<CR>
nnoremap <Space>gd :Gdiff<CR><C-w>h

" These only work in visual mode
vnoremap <Space>do :diffget<CR>
vnoremap <Space>dg :diffget<CR>
vnoremap <Space>dp :diffput<CR>

" FZF / fuzzy fining
nnoremap <Space>ff :FZF<CR>

    " FZF buffer stuff, from https://github.com/junegunn/fzf/wiki/Examples-%28vim%29
    function! s:buflist()
      redir => ls
      silent ls
      redir END
      return split(ls, '\n')
    endfunction
    
    function! s:bufopen(e)
      execute 'buffer' matchstr(a:e, '^[ 0-9]*')
    endfunction
    
    command! FZFBuff call fzf#run({
    \   'source':  reverse(<sid>buflist()),
    \   'sink':    function('<sid>bufopen'),
    \   'options': '+m',
    \   'down':    len(<sid>buflist()) + 2
    \ })<CR>
    
nnoremap <Space>fb :FZFBuff<CR>

    command! FZFMru call fzf#run({
                \'source': v:oldfiles,
                \'sink' : 'e ',
                \'options' : '-m',
                \})

nnoremap <Space>fr :FZFMru<CR>

    command! FZFTag if !empty(tagfiles()) | call fzf#run({
    \   'source': "sed '/^\\!/d;s/\t.*//' " . join(tagfiles()) . ' | uniq',
    \   'sink':   'tag',
    \ }) | else | echo 'No tags' | endif

nnoremap <Space>ft :FZFTag<CR>

    function! s:line_handler(l)
      let keys = split(a:l, ':\t')
      exec 'buf ' . keys[0]
      exec keys[1]
      normal! ^zz
    endfunction
    
    function! s:buffer_lines()
      let res = []
      for b in filter(range(1, bufnr('$')), 'buflisted(v:val)')
        call extend(res, map(getbufline(b,0,"$"), 'b . ":\t" . (v:key + 1) . ":\t" . v:val '))
      endfor
      return res
    endfunction
    
    command! FZFLines call fzf#run({
    \   'source':  <sid>buffer_lines(),
    \   'sink':    function('<sid>line_handler'),
    \   'options': '--extended --nth=3..',
    \   'down':    '60%'
    \})

nnoremap <Space>fl :FZFLines<CR>

" tab configuration
nnoremap < gT
nnoremap > gt

nnoremap <Space>1 1gt
nnoremap <Space>2 2gt
nnoremap <Space>3 3gt
nnoremap <Space>4 4gt
nnoremap <Space>5 5gt
nnoremap <Space>6 6gt
nnoremap <Space>7 7gt
nnoremap <Space>8 8gt
nnoremap <Space>9 9gt
nnoremap <Space>0 0gt

" Switch to last active tab; from
" http://stackoverflow.com/questions/2119754/switch-to-last-active-tab-in-vim
let g:lasttab = 1
nmap <Space><Space> :exe "tabn ".g:lasttab<CR>
au TabLeave * let g:lasttab = tabpagenr()

" Double column
nnoremap <Space>c :<C-u>let @z=&so<CR>:set so=0 noscb<CR>:bo vs<CR>Ljzt:setl scb<CR><C-w>p:setl scb<CR>:let &so=@z<CR>
nnoremap <Space>C <C-w>o

" Should learn to use this better
nnoremap <Space>u :GundoToggle<CR>

" Mostly unused packages, might want to retry them some day
nnoremap <Space>N :NERDTreeToggle<CR>
nnoremap <Space>r :NERDTreeToggle<CR>

"The important bits:

:filetype indent on
:filetype plugin on
:set autoindent
:set nobackup
"This is the option that allows undo levels.
:set nocompatible
:set noedcompatible
:set expandtab
:set shiftwidth=2
:set smarttab
:syntax on
:set textauto
:set notextmode
:set textwidth=68
:set iskeyword+=-

" Colors and such
set t_Co=256
set background=dark

colorscheme vividchalk

" Trying vividchalk for a while
" colorscheme ir_black

" " Very dark grey background; not bad, but trying out ir_black for now
" colorscheme inkpot

" " grey background eww
" colorscheme desert

" " Doesn't work with CSApprox, and hence is kind of terrible.
" colorscheme desert256

"********************
" HIGHLIGHTS
"
" Which are colorscheme-specific
"
" Note that we set *GUI* highlights, because that's how CSApprox works.
"********************
" "*****
" " ir_black
" "*****
" " Tabline customization
" highlight TabLine guibg=#000000 gui=NONE
" highlight TabLineSel guifg=#ff0000
" highlight TabLineFill guifg=White guibg=Black
" " Basic text is a bit intense
" highlight Normal           guifg=#dadada     guibg=black       gui=NONE      ctermfg=NONE        ctermbg=NONE        cterm=NONE
" " The fixed text is hard to read on a red background
" highlight DiffText       gui=bold guifg=White guibg=Red
" 
" " Makes # style comments do the right thing for some languages.
" autocmd FileType sh set comments=:#
" autocmd FileType sh set formatoptions=tcroq2
"*****
" vividchalk, which apparently has cterm as well as/rather than GUI
" values
"*****
" Tabline customization
highlight TabLine ctermbg=Black cterm=NONE
highlight TabLineSel ctermfg=Red
highlight TabLineFill ctermfg=Cyan ctermbg=Black cterm=NONE
" The search highlighting is a bit weak.
:highlight Search term=standout cterm=bold ctermfg=0 ctermbg=11 gui=bold guifg=Black guibg=#ffff00


" Do or do not break at whitespace
:map <F5> :setlocal linebreak<CR>
:map <F6> :setlocal nolinebreak<CR>

" Spell Check
:map <F7> :setlocal spell spelllang=en_us<CR>
:map <F8> :setlocal nospell<CR>

"Set up a key to toggle paste.
:map <F1> :setl paste<CR>
:map <F2> :setl nopaste<CR>
:imap <F1> <C-O>:setl paste<CR>
:imap <F2> <nop>
:setl pastetoggle=<F2>
:map <F3> :setl wrap<CR>
:map <F4> :setl nowrap<CR>

" Center search results.  This can also be done with a let for
" scrolloff; see http://vim.wikia.com/wiki/VimTip182
:nnoremap n nzz
:nnoremap N Nzz
:nnoremap * *zz
:nnoremap # #zz
:nnoremap g* g*zz
:nnoremap g# g#zz

" diff tweaks
set diffopt=filler,iwhite
set diffexpr=MyDiff() " See below for the definition

" Turn off pretty glyphs in vim2hs
let g:haskell_conceal = 0

" Per-language special stuff
autocmd BufReadPost,FileReadPost *.pp setl filetype=puppet
autocmd BufReadPost,FileReadPost *.scm.stx setl syntax=scheme
autocmd BufReadPost,FileReadPost *.scm.stx setl filetype=scheme
autocmd BufReadPost,FileReadPost *.lisp setl lisp
autocmd BufReadPost,FileReadPost *.cl setl lisp
autocmd BufNew,BufNewFile,BufRead *.md set filetype=markdown


" " Make tab do indentation of the whole line, even in insert mode
" " (and shift-tab unindent)
" vnoremap <C-T> >
" vnoremap <C-D> <LT>
" vmap <Tab> <C-T>
" vmap <S-Tab> <C-D>
" inoremap <Tab> <C-T>
" inoremap <S-Tab> <C-D>

" Stuff that I've reviewed but do not have specific comments about

set backspace=2
set history=1024
set ruler
set hidden             " very important with NERDTree
set hlsearch
set undolevels=10000
if version >= 703
  set undodir=/home/tmp/rlpowell/vimundo
  set undofile
endif

" Everything below here has probably not been properly reviewed

:set nodigraph
:set directory=.,~/tmp,/var/tmp,/tmp
:set endofline
:set equalalways
:set equalprg=
:set errorbells
:set errorfile=errors
:set errorformat=\"%f\",%*[^0-9]%l\ %m
:set esckeys
:set exrc
:set nogdefault
:set nographic
:set noicon
:set noignorecase
:set noinsertmode
:set nojoinspaces
:set keywordprg=ref
:set laststatus=1
:set nolist
:set magic
:set makeprg=make
:set maxmem=1024
:set maxmemtot=4096
:set modeline
:set modelines=5
:set more
:set nonumber
:set paragraphs=IPLPPPQPP\ LIpplpipbp
:set nopaste
:set patchmode=
:set noreadonly
:set remap
:set report=5
:set scroll=0
:set scrolljump=1
:set sections=SHNHH\ HUnhsh
:set secure
:set shell=$SHELL
:set shellpipe=2>&1\|tee
:set shelltype=0
:set shiftround
:set noshortname
:set showcmd
:set showmode
:set sidescroll=1
:set nosmartindent
:set nosplitbelow
:set suffixes=
:set tabstop=8
:set noterse
:set notildeop
:set notimeout
:set ttimeout
":set timeoutlen=200
:set notitle
:set nottyfast
:set updatecount=200
:set updatetime=4000
:set novisualbell
:set warn
:set noweirdinvert
:set whichwrap=3
:set nowrap
:set wrapmargin=0
:set wrapscan
:set nowriteany
:set writebackup

"******************
" Large Functions Go Here
"******************

" Make diffopt iwhite actually ignore whitespace, and set it on
function! MyDiff()
   let opt = ""
   if &diffopt =~ "icase"
     let opt = opt . "-i "
   endif
   if &diffopt =~ "iwhite"
     let opt = opt . "-w "
   endif
   silent execute "!diff -a --binary " . opt . v:fname_in . " " . v:fname_new .
        \  " > " . v:fname_out
endfunction

" FIXME: If we want to make the below more intelligent (like "shrink
" if necessary based on window size"),
" https://github.com/blueyed/dotfiles/blob/master/vimrc#L396 might
" make a good starting point (the ShortenFilename function), not
" because we want to do the same things but just to cargo cult.

" tabline customization function; started with the JonSkanes example
" from http://vim.wikia.com/wiki/Show_tab_number_in_your_tab_line
" and customized further
set showtabline=2  " 0, 1 or 2; when to use a tab pages line
set tabline=%!MyTabLine()  " custom tab pages line
function! MyTabLine()
  let s = '' " complete tabline goes here
  " loop through each tab page
  for t in range(tabpagenr('$'))
    " " set highlight for tab number and &modified
    let s .= '%#TabLineFill#'
    " set the tab page number (for mouse clicks)
    let s .= '%' . (t + 1) . 'T'
    " get buffer names and statuses
    let n = ''  "temp string for buffer names while we loop and check buftype
    let m = 0  " &modified counter
    let bc = len(tabpagebuflist(t + 1))  "counter to avoid last ' '
    " loop through each buffer in a tab
    for b in tabpagebuflist(t + 1)
      " buffer types: quickfix gets a [Q], help gets [H]{base fname}
      " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
      if getbufvar( b, "&buftype" ) == 'help'
        let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
      elseif getbufvar( b, "&buftype" ) == 'quickfix'
        let n .= '[Q]'
      else
        " Enforce file name maxlen
        let bufname = bufname(b)
        let bufname = substitute(bufname, 'manifests/', 'm/', 'g')
        let bufname = substitute(bufname, 'modules/', 'm/', 'g')
        let bufname = substitute(bufname, 'templates/', 'm/', 'g')
        let bufname = substitute(bufname, 'init.pp', 'ip', 'g')
        let bufname = substitute(bufname, 'files/', 'f/', 'g')
        let bufname = substitute(bufname, 'lib/', 'l/', 'g')
        let bufname = substitute(bufname, 'pages/', 'p/', 'g')
        let bufname = substitute(bufname, 'cloud/', 'c/', 'g')
        let n .= bufname[-30:-1]
      endif
      " check and ++ tab's &modified count
      if getbufvar( b, "&modified" )
        let m += 1
      endif
      " no final ' ' added...formatting looks better done later
      if bc > 1
        let n .= ' '
      endif
      let bc -= 1
    endfor
    " set page number string
    let s .= 't'
    let s .= t + 1
    " add modified label
    if m > 0
      let s .= '+'
    endif
    let s .= ':'
    " select the highlighting for the buffer names
    " my default highlighting only underlines the active tab
    " buffer names.
    if t + 1 == tabpagenr()
      let s .= '%#TabLineSel#'
    else
      let s .= '%#TabLine#'
    endif
    " add buffer names
    let s .= n
    " switch to no underlining and add final space to buffer list
    let s .= '%#TabLineSel#' . ' '
  endfor
  " after the last tab fill with TabLineFill and reset tab page nr
  let s .= '%#TabLineFill#%T'
  " right-align the label to close the current tab page
  if tabpagenr('$') > 1
    let s .= '%=%#TabLineFill#%999Xclose'
  endif
  return s
endfunction

" Last so we can override stuff
silent! source ~/.vimrc-local
